
declare type AnySchemaObject = SchemaObject | AsyncSchema;

declare interface AsyncSchema extends _SchemaObject {
    $async: true;
}

/**
 * Different supported chain ids
 * @alpha
 */
declare enum ChainId {
    ETHEREUM_MAINNET = 1,
    ETHEREUM_ROPSTEN = 3,
    ETHEREUM_RINKEBY = 4,
    ETHEREUM_GOERLI = 5,
    ETHEREUM_KOVAN = 42,
    MATIC_MAINNET = 137,
    MATIC_MUMBAI = 80001
}

/**
 * @alpha
 */
declare namespace ChainId {
    const schema: JSONSchema<ChainId>;
    const validate: ValidateFunction<ChainId>;
}

export declare type Configuration = {
    serverURL: string;
};

export declare type ContractData = {
    abi: object[];
    address: string;
    name: string;
    version: string;
    chainId: ChainId;
};

export declare enum ContractName {
    Bid = "Bid",
    BidV2 = "BidV2",
    CollectionFactory = "CollectionFactory",
    CollectionFactoryV3 = "CollectionFactoryV3",
    CollectionManager = "CollectionManager",
    CollectionStore = "CollectionStore",
    Committee = "Committee",
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC721CollectionV2 = "ERC721CollectionV2",
    Forwarder = "Forwarder",
    MANAToken = "MANAToken",
    Marketplace = "Marketplace",
    MarketplaceV2 = "MarketplaceV2",
    Rarities = "Rarities",
    RaritiesWithOracle = "RaritiesWithOracle",
    ThirdPartyRegistry = "ThirdPartyRegistry",
    Tiers = "Tiers",
    ChainlinkOracle = "ChainlinkOracle",
    Rentals = "Rentals"
}

export declare type DataToSign = {
    types: {
        EIP712Domain: DomainType[];
        MetaTransaction: MetaTransactionType[];
    };
    domain: DomainData;
    primaryType: 'MetaTransaction';
    message: {
        nonce: number;
        from: string;
        functionSignature: FunctionSignature;
    };
};

export declare const DOMAIN_TYPE: DomainType[];

export declare type DomainData = {
    name: string;
    version: string;
    verifyingContract: string;
    salt: string;
};

export declare type DomainType = {
    name: string;
    type: string;
};

export declare interface EIPProvider {
    request: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    sendAsync?: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    send?: (method: string, params?: any[]) => Promise<any>;
}

export declare enum ErrorCode {
    UNKNOWN = "unknown",
    DAPP_LIMIT_REACHED = "dapp_limit_reached",
    USER_LIMIT_REACHED = "user_limit_reached",
    API_LIMIT_REACHED = "api_limit_reached",
    GAS_LIMIT_REACHED = "gas_limit_reached",
    EXPECTATION_FAILED = "expectation_failed",
    INVALID_TRANSACTION = "invalid_transaction",
    INVALID_SCHEMA = "invalid_schema",
    INVALID_CONTRACT_ADDRESS = "invalid_contract_address",
    INVALID_ADDRESS = "invalid_address",
    SALE_PRICE_TOO_LOW = "sale_price_too_low",
    QUOTA_REACHED = "quota_reached",
    CONTRACT_ACCOUNT = "contract_account",
    USER_DENIED = "user_denied"
}

declare interface ErrorObject<K extends string = string, P = Record<string, any>, S = unknown> {
    keyword: K;
    dataPath: string;
    instancePath?: string;
    schemaPath: string;
    params: P;
    propertyName?: string;
    message?: string;
    schema?: S;
    parentSchema?: AnySchemaObject;
    data?: unknown;
}

export declare type FunctionSignature = string;

export declare function getContract(contractName: ContractName, chainId: ChainId): ContractData;

export declare function getContractName(address: string): ContractName;

export declare function isContract(provider: Provider, account: string): Promise<boolean>;

/**
 * This type alias exist only to avoid accidental refactors involving names of ajv
 * @public
 */
declare type JSONSchema<T> = JSONSchemaType<T>;

declare type JSONSchemaType<T, _partial extends boolean = false> = (T extends number ? {
    type: JSONType<"number" | "integer", _partial>;
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    format?: string;
} : T extends string ? {
    type: JSONType<"string", _partial>;
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: string;
} : T extends boolean ? {
    type: "boolean";
} : T extends [any, ...any[]] ? {
    type: JSONType<"array", _partial>;
    items: {
        readonly [K in keyof T]-?: JSONSchemaType<T[K]> & Nullable<T[K]>;
    } & {
        length: T["length"];
    };
    minItems: T["length"];
} & ({
    maxItems: T["length"];
} | {
    additionalItems: false;
}) : T extends readonly any[] ? {
    type: JSONType<"array", _partial>;
    items: JSONSchemaType<T[0]>;
    contains?: PartialSchema<T[0]>;
    minItems?: number;
    maxItems?: number;
    minContains?: number;
    maxContains?: number;
    uniqueItems?: true;
    additionalItems?: never;
} : T extends Record<string, any> ? {
    type: JSONType<"object", _partial>;
    required: _partial extends true ? Readonly<(keyof T)[]> : Readonly<RequiredMembers<T>[]>;
    additionalProperties?: boolean | JSONSchemaType<T[string]>;
    unevaluatedProperties?: boolean | JSONSchemaType<T[string]>;
    properties?: _partial extends true ? Partial<PropertiesSchema<T>> : PropertiesSchema<T>;
    patternProperties?: {
        [Pattern in string]?: JSONSchemaType<T[string]>;
    };
    propertyNames?: JSONSchemaType<string>;
    dependencies?: {
        [K in keyof T]?: Readonly<(keyof T)[]> | PartialSchema<T>;
    };
    dependentRequired?: {
        [K in keyof T]?: Readonly<(keyof T)[]>;
    };
    dependentSchemas?: {
        [K in keyof T]?: PartialSchema<T>;
    };
    minProperties?: number;
    maxProperties?: number;
} : T extends null ? {
    nullable: true;
} : never) & {
    [keyword: string]: any;
    $id?: string;
    $ref?: string;
    $defs?: {
        [Key in string]?: JSONSchemaType<Known, true>;
    };
    definitions?: {
        [Key in string]?: JSONSchemaType<Known, true>;
    };
    allOf?: Readonly<PartialSchema<T>[]>;
    anyOf?: Readonly<PartialSchema<T>[]>;
    oneOf?: Readonly<PartialSchema<T>[]>;
    if?: PartialSchema<T>;
    then?: PartialSchema<T>;
    else?: PartialSchema<T>;
    not?: PartialSchema<T>;
};

declare type JSONType<T extends string, _partial extends boolean> = _partial extends true ? T | undefined : T;

declare type Known = KnownRecord | [Known, ...Known[]] | Known[] | number | string | boolean | null;

declare interface KnownRecord extends Record<string, Known> {
}

export declare interface LegacyProvider {
    sendAsync?: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    send: (method: string, params: any[]) => Promise<any>;
}

export declare const META_TRANSACTION_TYPE: MetaTransactionType[];

export declare class MetaTransactionError extends Error {
    code: ErrorCode;
    constructor(message: string, code: ErrorCode);
}

export declare type MetaTransactionType = {
    name: string;
    type: string;
};

export declare type MetaTxData = {
    functionSignature: string;
    contractData: ContractData;
};

declare type Nullable<T> = undefined extends T ? {
    nullable: true;
    const?: never;
    enum?: Readonly<(T | null)[]>;
    default?: T | null;
} : {
    const?: T;
    enum?: Readonly<T[]>;
    default?: T;
};

declare type PartialSchema<T> = Partial<JSONSchemaType<T, true>>;

declare type PropertiesSchema<T> = {
    [K in keyof T]-?: (JSONSchemaType<T[K]> & Nullable<T[K]>) | {
        $ref: string;
    };
};

export declare type Provider = EIPProvider | LegacyProvider;

declare type RequiredMembers<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];

declare interface SchemaObject extends _SchemaObject {
    $id?: string;
    $schema?: string;
    $async?: false;
    [x: string]: any;
}

declare interface _SchemaObject {
    $id?: string;
    $schema?: string;
    [x: string]: any;
}

/**
 * Send a meta transaction using a relay server
 * @param provider Which network you are connected to and therefore where the meta transaction will be signed
 * @param metaTransactionProvider Where the meta transaction will be executed
 * @param functionSignature Hexa of the transaction data you want to execute
 * @param contractData Related contract data necessary to execute the transaction. Check getContract from this same package
 * @param partialConfiguration Configurable params like which relay server to use
 */
export declare function sendMetaTransaction(provider: Provider, metaTransactionProvider: Provider, functionSignature: string, contractData: ContractData, partialConfiguration?: Partial<Configuration>): Promise<string>;

/**
 * This type is a subset of AJV's ValidateFunction, it exists to make
 * .d.ts bundles smaller and to not expose all of AJV context to the
 * world.
 * @public
 */
declare interface ValidateFunction<T = unknown> {
    (this: any, data: any, dataCxt?: any): data is T;
    errors?: null | ErrorObject[];
}

export { }
