
declare type AnySchemaObject = SchemaObject | AsyncSchema;

declare interface AsyncSchema extends _SchemaObject {
    $async: true;
}

/**
 * Different supported chain ids
 * @alpha
 */
declare enum ChainId {
    ETHEREUM_MAINNET = 1,
    ETHEREUM_ROPSTEN = 3,
    ETHEREUM_RINKEBY = 4,
    ETHEREUM_GOERLI = 5,
    ETHEREUM_KOVAN = 42,
    ETHEREUM_SEPOLIA = 11155111,
    MATIC_MAINNET = 137,
    MATIC_MUMBAI = 80001
}

/**
 * @alpha
 */
declare namespace ChainId {
    const schema: JSONSchema<ChainId>;
    const validate: ValidateFunction<ChainId>;
}

export declare type Configuration = {
    serverURL: string;
};

export declare type ContractData = {
    abi: object[];
    address: string;
    name: string;
    version: string;
    chainId: ChainId;
};

export declare enum ContractName {
    Bid = "Bid",
    BidV2 = "BidV2",
    CollectionFactory = "CollectionFactory",
    CollectionFactoryV3 = "CollectionFactoryV3",
    CollectionManager = "CollectionManager",
    CollectionStore = "CollectionStore",
    Committee = "Committee",
    ERC20 = "ERC20",
    ERC721 = "ERC721",
    ERC721CollectionV2 = "ERC721CollectionV2",
    Forwarder = "Forwarder",
    MANAToken = "MANAToken",
    Marketplace = "Marketplace",
    MarketplaceV2 = "MarketplaceV2",
    Rarities = "Rarities",
    RaritiesWithOracle = "RaritiesWithOracle",
    ThirdPartyRegistry = "ThirdPartyRegistry",
    Tiers = "Tiers",
    ChainlinkOracle = "ChainlinkOracle",
    Rentals = "Rentals",
    DCLRegistrar = "DCLRegistrar",
    DCLController = "DCLController",
    DCLControllerV2 = "DCLControllerV2"
}

export declare type DataToSign = {
    types: {
        EIP712Domain: DomainType[];
        MetaTransaction: MetaTransactionType[];
    };
    domain: DomainData;
    primaryType: 'MetaTransaction';
    message: {
        nonce: number;
        from: string;
        functionSignature: FunctionSignature;
    };
};

export declare const DOMAIN_TYPE: DomainType[];

export declare type DomainData = {
    name: string;
    version: string;
    verifyingContract: string;
    salt: string;
};

export declare type DomainType = {
    name: string;
    type: string;
};

export declare interface EIPProvider {
    request: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    sendAsync?: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    send?: (method: string, params?: any[]) => Promise<any>;
}

export declare enum ErrorCode {
    UNKNOWN = "unknown",
    DAPP_LIMIT_REACHED = "dapp_limit_reached",
    USER_LIMIT_REACHED = "user_limit_reached",
    API_LIMIT_REACHED = "api_limit_reached",
    GAS_LIMIT_REACHED = "gas_limit_reached",
    EXPECTATION_FAILED = "expectation_failed",
    INVALID_TRANSACTION = "invalid_transaction",
    INVALID_SCHEMA = "invalid_schema",
    INVALID_CONTRACT_ADDRESS = "invalid_contract_address",
    INVALID_ADDRESS = "invalid_address",
    SALE_PRICE_TOO_LOW = "sale_price_too_low",
    QUOTA_REACHED = "quota_reached",
    CONTRACT_ACCOUNT = "contract_account",
    HIGH_CONGESTION = "high_congestion",
    USER_DENIED = "user_denied"
}

declare interface ErrorObject<K extends string = string, P = Record<string, any>, S = unknown> {
    keyword: K;
    instancePath: string;
    schemaPath: string;
    params: P;
    propertyName?: string;
    message?: string;
    schema?: S;
    parentSchema?: AnySchemaObject;
    data?: unknown;
}

export declare type FunctionSignature = string;

export declare function getContract(contractName: ContractName, chainId: ChainId): ContractData;

export declare function getContractName(address: string): ContractName;

export declare function isContract(provider: Provider, account: string): Promise<boolean>;

/**
 * This type alias exist only to avoid accidental refactors involving names of ajv
 * @public
 */
declare type JSONSchema<T> = JSONSchemaType<T>;

declare type JSONSchemaType<T> = StrictNullChecksWrapper<"JSONSchemaType", UncheckedJSONSchemaType<T, false>>;

declare type JSONType<T extends string, IsPartial extends boolean> = IsPartial extends true ? T | undefined : T;

declare type Known = {
    [key: string]: Known;
} | [Known, ...Known[]] | Known[] | number | string | boolean | null;

export declare interface LegacyProvider {
    sendAsync?: (reqArgs: {
        method: string;
        params?: any[];
    }) => Promise<any>;
    send: (method: string, params: any[]) => Promise<any>;
}

export declare const META_TRANSACTION_TYPE: MetaTransactionType[];

export declare class MetaTransactionError extends Error {
    code: ErrorCode;
    constructor(message: string, code: ErrorCode);
}

export declare type MetaTransactionType = {
    name: string;
    type: string;
};

export declare type MetaTxData = {
    functionSignature: string;
    contractData: ContractData;
};

declare type Nullable<T> = undefined extends T ? {
    nullable: true;
    const?: null;
    enum?: Readonly<(T | null)[]>;
    default?: T | null;
} : {
    nullable?: false;
    const?: T;
    enum?: Readonly<T[]>;
    default?: T;
};

declare interface NumberKeywords {
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    format?: string;
}

export declare type Provider = EIPProvider | LegacyProvider;

declare interface SchemaObject extends _SchemaObject {
    id?: string;
    $id?: string;
    $schema?: string;
    $async?: false;
    [x: string]: any;
}

declare interface _SchemaObject {
    id?: string;
    $id?: string;
    $schema?: string;
    [x: string]: any;
}

/**
 * Send a meta transaction using a relay server
 * @param provider Which network you are connected to and therefore where the meta transaction will be signed
 * @param metaTransactionProvider Where the meta transaction will be executed
 * @param functionSignature Hexa of the transaction data you want to execute
 * @param contractData Related contract data necessary to execute the transaction. Check getContract from this same package
 * @param partialConfiguration Configurable params like which relay server to use
 */
export declare function sendMetaTransaction(provider: Provider, metaTransactionProvider: Provider, functionSignature: string, contractData: ContractData, partialConfiguration?: Partial<Configuration>): Promise<string>;

declare type StrictNullChecksWrapper<Name extends string, Type> = undefined extends null ? `strictNullChecks must be true in tsconfig to use ${Name}` : Type;

declare interface StringKeywords {
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: string;
}

declare type UncheckedJSONSchemaType<T, IsPartial extends boolean> = (// these two unions allow arbitrary unions of types
{
    anyOf: readonly UncheckedJSONSchemaType<T, IsPartial>[];
} | {
    oneOf: readonly UncheckedJSONSchemaType<T, IsPartial>[];
} | ({
    type: readonly (T extends number ? JSONType<"number" | "integer", IsPartial> : T extends string ? JSONType<"string", IsPartial> : T extends boolean ? JSONType<"boolean", IsPartial> : never)[];
} & UnionToIntersection<T extends number ? NumberKeywords : T extends string ? StringKeywords : T extends boolean ? {} : never>) | ((T extends number ? {
    type: JSONType<"number" | "integer", IsPartial>;
} & NumberKeywords : T extends string ? {
    type: JSONType<"string", IsPartial>;
} & StringKeywords : T extends boolean ? {
    type: JSONType<"boolean", IsPartial>;
} : T extends readonly [any, ...any[]] ? {
    type: JSONType<"array", IsPartial>;
    items: {
        readonly [K in keyof T]-?: UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>;
    } & {
        length: T["length"];
    };
    minItems: T["length"];
} & ({
    maxItems: T["length"];
} | {
    additionalItems: false;
}) : T extends readonly any[] ? {
    type: JSONType<"array", IsPartial>;
    items: UncheckedJSONSchemaType<T[0], false>;
    contains?: UncheckedPartialSchema<T[0]>;
    minItems?: number;
    maxItems?: number;
    minContains?: number;
    maxContains?: number;
    uniqueItems?: true;
    additionalItems?: never;
} : T extends Record<string, any> ? {
    type: JSONType<"object", IsPartial>;
    additionalProperties?: boolean | UncheckedJSONSchemaType<T[string], false>;
    unevaluatedProperties?: boolean | UncheckedJSONSchemaType<T[string], false>;
    properties?: IsPartial extends true ? Partial<UncheckedPropertiesSchema<T>> : UncheckedPropertiesSchema<T>;
    patternProperties?: Record<string, UncheckedJSONSchemaType<T[string], false>>;
    propertyNames?: Omit<UncheckedJSONSchemaType<string, false>, "type"> & {
        type?: "string";
    };
    dependencies?: {
        [K in keyof T]?: Readonly<(keyof T)[]> | UncheckedPartialSchema<T>;
    };
    dependentRequired?: {
        [K in keyof T]?: Readonly<(keyof T)[]>;
    };
    dependentSchemas?: {
        [K in keyof T]?: UncheckedPartialSchema<T>;
    };
    minProperties?: number;
    maxProperties?: number;
} & (IsPartial extends true ? {
    required: Readonly<(keyof T)[]>;
} : [UncheckedRequiredMembers<T>] extends [never] ? {
    required?: Readonly<UncheckedRequiredMembers<T>[]>;
} : {
    required: Readonly<UncheckedRequiredMembers<T>[]>;
}) : T extends null ? {
    type: JSONType<"null", IsPartial>;
    nullable: true;
} : never) & {
    allOf?: Readonly<UncheckedPartialSchema<T>[]>;
    anyOf?: Readonly<UncheckedPartialSchema<T>[]>;
    oneOf?: Readonly<UncheckedPartialSchema<T>[]>;
    if?: UncheckedPartialSchema<T>;
    then?: UncheckedPartialSchema<T>;
    else?: UncheckedPartialSchema<T>;
    not?: UncheckedPartialSchema<T>;
})) & {
    [keyword: string]: any;
    $id?: string;
    $ref?: string;
    $defs?: Record<string, UncheckedJSONSchemaType<Known, true>>;
    definitions?: Record<string, UncheckedJSONSchemaType<Known, true>>;
};

declare type UncheckedPartialSchema<T> = Partial<UncheckedJSONSchemaType<T, true>>;

declare type UncheckedPropertiesSchema<T> = {
    [K in keyof T]-?: (UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>) | {
        $ref: string;
    };
};

declare type UncheckedRequiredMembers<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
}[keyof T];

declare type UnionToIntersection<U> = (U extends any ? (_: U) => void : never) extends (_: infer I) => void ? I : never;

/**
 * This type is a subset of AJV's ValidateFunction, it exists to make
 * .d.ts bundles smaller and to not expose all of AJV context to the
 * world.
 * @public
 */
declare interface ValidateFunction<T = unknown> {
    (this: any, data: any, dataCxt?: any): data is T;
    errors?: null | ErrorObject[];
}

export { }
